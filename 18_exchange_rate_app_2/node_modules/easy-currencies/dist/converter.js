"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Converter = exports.Convert = void 0;
const requester_1 = require("./parts/requester");
const config_1 = require("./parts/config");
var chainer_1 = require("./parts/chainer");
Object.defineProperty(exports, "Convert", { enumerable: true, get: function () { return chainer_1.Chainer; } });
const utils_1 = require("./parts/utils");
const axios_1 = __importDefault(require("axios"));
/**
 * Regular converter class definition.
 *
 * @export
 * @class Converter
 */
class Converter {
    /**
     * Creates an instance of Converter.
     * @param {(...ProviderReference[] | undefined[] | string[])} config
     * @memberof Converter
     */
    constructor(...config) {
        /**
         * Method to set the proxy configuration.
         * @param proxyConfiguration  The proxy configuration.
         */
        this.setProxyConfiguration = (proxyConfiguration) => {
            this.config.setClient(axios_1.default.create({ proxy: proxyConfiguration }));
        };
        /**
         * Conversion function (non chainable).
         *
         * @example
         * const converter = new Converter()
         * const converted = await converter.convert(15,"USD","EUR")
         * console.log(converted);
         *
         * @param {number} amount - amount to be converted
         * @param {string} from - base currency
         * @param {string} to - conversion currency
         * @param {any} rates - conversion rates, if they were pre-fetched
         * @returns {Promise<number>} - converted amount
         */
        this.convert = (amount_1, from_1, to_1, ...args_1) => __awaiter(this, [amount_1, from_1, to_1, ...args_1], void 0, function* (amount, from, to, rates = undefined) {
            // Returining conversion from provided rates
            if (typeof rates !== "undefined") {
                return this.convertRate(amount, to, rates);
            }
            //Fetching conversion rates from the active provider
            const [err, data] = yield (0, utils_1._to)(this.getRates(from, to, false));
            if (err) {
                throw err;
            }
            if (!data || Object.keys(data).length == 0) {
                throw new Error("No data returned for rate fetch.");
            }
            // Normalizing resulting rates data
            return this.convertRate(amount, to, data);
        });
        /**
         * Performs safe multiplication to get the result amount.
         * @param {number} amount - amount to be converted
         * @param {string} to - conversion currency
         * @param {any} rates - conversion rates, if they were pre-fetched
         * @returns
         */
        this.convertRate = (amount, to, rates = undefined) => {
            const keys = Object.keys(rates);
            const rateKey = keys.find(key => key.toLowerCase() === to.toLowerCase());
            const rate = rateKey ? rates[rateKey] : undefined;
            if (!rate) {
                throw new Error(`No '${to}' present in rates: ${JSON.stringify(rates, null, 2)}`);
            }
            const numericRate = parseFloat(rate);
            if (isNaN(numericRate)) {
                throw new Error(`Invalid rate value for '${to}': ${rate}`);
            }
            return amount * numericRate;
        };
        /**
         * Rate fetch function
         * @param {string} from - base currency
         * @param {string} to - conversion currency
         * @param {boolean} multiple - determines conversion mode
         * @returns
         */
        this.getRates = (from_2, to_2, ...args_2) => __awaiter(this, [from_2, to_2, ...args_2], void 0, function* (from, to, multiple = false) {
            // Getting the current active provider
            const provider = this.config.activeProvider();
            // Getting the client
            const client = this.config.getClient();
            // Fetching conversion rates from the active provider.
            const [err, data] = yield (0, utils_1._to)((0, requester_1.fetchRates)(client, provider, {
                FROM: from,
                TO: to,
                multiple: multiple
            }));
            // error handling:
            // if the error is not in the registered list of errors (is undefined), then throw.
            // if the error is in the list, but there are no backup providers, then throw.
            // if the error is in the list and there is a backup, log the error and continue.
            if (!err) {
                return provider.handler(data);
            }
            // unrecognized error
            if (!err.handled) {
                throw err.error;
            }
            // logging existing error
            console.error(err.error);
            if (this.config.providers.length <= 1) {
                throw err.error;
            }
            // removing current provider from active list
            this.config.remove(provider);
            // Retrying...
            return this.getRates(from, to, multiple);
        });
        this.config = new config_1.Config(...config);
        // Forwarding config adder function (with the alternative handle)
        this.add = this.config.add;
        this.addProvider = this.config.add;
        // Forwarding config multiple adder function (with the alternative handle)
        this.addMultiple = this.config.addMultiple;
        this.addMultipleProviders = this.config.addMultiple;
        this.remove = this.config.remove;
    }
    /**
     * Getters for active providers
     *
     * @readonly
     * @type {Provider[]}
     * @memberof Converter
     */
    get providers() {
        return this.config.providers;
    }
    get active() {
        return this.config.providers;
    }
}
exports.Converter = Converter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NvbnZlcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpREFBK0M7QUFFL0MsMkNBQTREO0FBQzVELDJDQUFxRDtBQUE1QyxrR0FBQSxPQUFPLE9BQVc7QUFDM0IseUNBQW9DO0FBQ3BDLGtEQUEwQjtBQVkxQjs7Ozs7R0FLRztBQUNILE1BQWEsU0FBUztJQVNwQjs7OztPQUlHO0lBQ0gsWUFBWSxHQUFHLE1BQW9EO1FBcUNuRTs7O1dBR0c7UUFDSCwwQkFBcUIsR0FBRyxDQUFDLGtCQUFzQyxFQUFFLEVBQUU7WUFDakUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsZUFBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxrQkFBa0IsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNyRSxDQUFDLENBQUM7UUFFRjs7Ozs7Ozs7Ozs7OztXQWFHO1FBQ0gsWUFBTyxHQUFHLG9DQUtTLEVBQUUseUVBSm5CLE1BQWMsRUFDZCxJQUFZLEVBQ1osRUFBVSxFQUNWLFFBQWEsU0FBUztZQUV0Qiw0Q0FBNEM7WUFDNUMsSUFBSSxPQUFPLEtBQUssS0FBSyxXQUFXLEVBQUUsQ0FBQztnQkFDakMsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDN0MsQ0FBQztZQUVELG9EQUFvRDtZQUNwRCxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLE1BQU0sSUFBQSxXQUFHLEVBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFFOUQsSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDUixNQUFNLEdBQUcsQ0FBQztZQUNaLENBQUM7WUFFRCxJQUFJLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENB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